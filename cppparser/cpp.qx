// -*- C++ -*- vim: set syntax=cpp:
start = PROGRAM;

define {
    // Pattern definitions for example application
    P_WHITESPACE          [ \r\t\n]+
    P_IDENTIFIER          [_a-zA-Z][_a-zA-Z0-9]*
    P_NUMBER              [0-9]+
    //
    // String: 
    //    Quote " followe by either \" or something different from " and then a final "
    P_STRING              "\""(\\"\""|[^"])*"\""
    P_QUOTED_CHAR_1       ("'\\''")|("'"[^']?"'")
    P_QUOTED_CHAR_2       "'\\"[0-9abcfnrtv\\]"'"
    P_QUOTED_CHAR         ({P_QUOTED_CHAR_1}|{P_QUOTED_CHAR_2})
    P_INCLUDE_FILE1       "<"[^>]+">"
    P_INCLUDE_FILE2       "\""[^"]+"\""
	
    exponent_part         [eE][\-+]?[0-9]+
    fractional_constant   ([0-9]*"."[0-9]+)|([0-9]+".")
    floating_constant     (({fractional_constant}{exponent_part}?)|([0-9]+{exponent_part}))[FfLl]?

	integer_suffix_opt    ([uU]?[lL]?)|([lL][uU])
	decimal_constant      [1-9][0-9]*{integer_suffix_opt}
	octal_constant        "0"[0-7]*{integer_suffix_opt}
	hex_constant          "0"[xX][0-9a-fA-F]+{integer_suffix_opt}
}

token {

CORNER_BRACKET_O = 20;
CORNER_BRACKET_C = 21;
OP_ASSIGNMENT =22;
PLUS = 23;
MINUS = 24;
DIV = 25;
MODULO = 26;
ASSIGN_PLUS =27;
ASSIGN_MINUS = 28;
ASSIGN_MULT= 29;
ASSIGN_DIV= 30;
DOT= 31;
LEFT_SHIFT = 32;        
RIGHT_SHIFT =33;
}

mode EOF_AND_FAILURE:
<inheritable: only>
{
    on_end_of_stream => TKN_TERMINATION(LexemeNull);
	on_failure       => TKN_TERMINATION(Lexeme);
}

mode OPERATORS:
<inheritable: only>
{
    "?"   => TKN_QUESTION_MARK(LexemeNull);
    "~"   => TKN_TILDE(LexemeNull);
    "("   => TKN_BRACKET_O(LexemeNull);
    ")"   => TKN_BRACKET_C(LexemeNull);
    "{"   => TKN_CURLY_BRACKET_O(LexemeNull);
    "}"   => TKN_CURLY_BRACKET_C(LexemeNull);
	"*"   => TKN_MULT(LexemeNull);
	"["   => TKN_CORNER_BRACKET_O(LexemeNull);
    "]"   => TKN_CORNER_BRACKET_C(LexemeNull);
    "="   => TKN_OP_ASSIGNMENT(LexemeNull);
    "+"   => TKN_PLUS(LexemeNull);
    "-"   => TKN_MINUS(LexemeNull);
    "/"   => TKN_DIV(LexemeNull);
    "%"   => TKN_MODULO(LexemeNull);
    "+="  => TKN_ASSIGN_PLUS(LexemeNull);
    "-="  => TKN_ASSIGN_MINUS(LexemeNull);
    "*="  => TKN_ASSIGN_MULT(LexemeNull);
    "/="  => TKN_ASSIGN_DIV(LexemeNull);
	"."   => TKN_DOT(LexemeNull);
	"<<"  => TKN_LEFT_SHIFT(LexemeNull);             
    ">>"  => TKN_RIGHT_SHIFT(LexemeNull);            
    "=="  => TKN_EQ(LexemeNull);
    "!="  => TKN_NOT_EQ(LexemeNull);
    ">"   => TKN_GREATER(LexemeNull);
    ">="  => TKN_GR_EQ(LexemeNull);
    "<"   => TKN_LESS(LexemeNull);
    "<="  => TKN_LE_EQ(LexemeNull);
    "!"   => TKN_NOT(LexemeNull);
    "|"   => TKN_LOGICAL_OR(LexemeNull);
    "^"   => TKN_EXCLUSIVE_OR(LexemeNull);
    "||"  => TKN_OR(LexemeNull);
    "&"   => TKN_AMPERSANT(LexemeNull);
    "&&"  => TKN_AND(LexemeNull);
    ":"   => TKN_COLON(LexemeNull);
	"::"  => TKN_DOUBLE_COLON(LexemeNull);
    ";"   => TKN_SEMICOLON(LexemeNull);
    ","   => TKN_COMMA(LexemeNull);
}

mode VAR_LEXEMES :
<inheritable: only>
{
    {P_IDENTIFIER}  => TKN_IDENTIFIER(Lexeme);
    {P_NUMBER}      => TKN_NUMBER(Lexeme);
    {P_STRING}      => TKN_STRING(Lexeme);
    {P_QUOTED_CHAR} => TKN_QUOTED_CHAR(Lexeme);

	{decimal_constant}  => TKN_NUMBER(Lexeme);
    {octal_constant}    => TKN_NUMBER(Lexeme);
    {hex_constant}      => TKN_NUMBER(Lexeme);
    {floating_constant} => TKN_NUMBER(Lexeme);
}


mode PROGRAM : OPERATORS, 
               VAR_LEXEMES, 
               EOF_AND_FAILURE
<skip:       [ \r\n\t]>
<skip_range: "/*" "*/">
<skip_range: "//" "\n">
{
    "#"[ \t]*"include"[ \t]*{P_INCLUDE_FILE2} => TKN_PP_INCLUDE(Lexeme);
    "#"[ \t]*"include"[ \t]*{P_INCLUDE_FILE1} => TKN_PP_INCLUDE(Lexeme);
    "#"[ \t]*"define"                         => GOTO(PREPROCESSOR, TKN_PP_DEFINE(LexemeNull));
    "#"[ \t]*"if"                             => GOTO(PREPROCESSOR, TKN_PP_IF(LexemeNull));
    "#"[ \t]*"elif"                           => GOTO(PREPROCESSOR, TKN_PP_ELIF(LexemeNull));
    "#"[ \t]*"ifdef"                          => GOTO(PREPROCESSOR, TKN_PP_IFDEF(LexemeNull));
    "#"[ \t]*"ifndef"                         => GOTO(PREPROCESSOR, TKN_PP_IFNDEF(LexemeNull));
    "#"[ \t]*"endif"                          => GOTO(PREPROCESSOR, TKN_PP_ENDIF(LexemeNull));
    "#"[ \t]*"else"                           => GOTO(PREPROCESSOR, TKN_PP_ELSE(LexemeNull));
    "#"[ \t]*"pragma"                         => GOTO(PREPROCESSOR, TKN_PP_PRAGMA(LexemeNull));
    "#"[ \t]*"error"                          => GOTO(PREPROCESSOR, TKN_PP_ERROR(LexemeNull));
    "#"[ \t]*"undef"                          => GOTO(PREPROCESSOR, TKN_PP_UNDEF(LexemeNull));
    "\\\n"        {}

    "#"           => TKN_HASH(LexemeNull);
    "##"          => TKN_DOUBLE_HASH(LexemeNull);
    struct        => TKN_STRUCT(LexemeNull);
    const         => TKN_CONST(LexemeNull);
    if            => TKN_IF(LexemeNull);
    else          => TKN_ELSE(LexemeNull);
    switch        => TKN_SWITCH(LexemeNull);
    for           => TKN_FOR(LexemeNull);
    do            => TKN_DO(LexemeNull);
    while         => TKN_WHILE(LexemeNull);
    break         => TKN_BREAK(LexemeNull);
    continue      => TKN_CONTINUE(LexemeNull);
	class         => TKN_CLASS(LexemeNull);
	template      => TKN_TEMPLATE(LexemeNull);
	extern        => TKN_EXTERN(LexemeNull);
	return		  => TKN_RETURN(LexemeNull);
	public        => TKN_PUBLIC(LexemeNull);
	protect       => TKN_PROTECT(LexemeNull);
	private       => TKN_PRIVATE(LexemeNull);
	delete        => TKN_DELETE(LexemeNull);
	friend        => TKN_FRIEND(LexemeNull);
	namespace     => TKN_NAMESPACE(LexemeNull);
	new           => TKN_NEW(LexemeNull);
	__asm         => TKN_ASM(LexemeNull);
	union         => TKN_UNION(LexemeNull);
	virtual       => TKN_VIRTUAL(LexemeNull);
	typename      => TKN_TYPENAME(LexemeNull);  
	using         => TKN_USING(LexemeNull);
    static        => TKN_STATIC(LexemeNull);
    operator      => TKN_OPERATOR(LexemeNull);
    inline        => TKN_INLINE(LexemeNull);
	enum          => TKN_ENUM(LexemeNull);
	typedef       => TKN_TYPEDEF(LexemeNull);
	volatile      => TKN_VOLATILE(LexemeNull);
	{P_IDENTIFIER}  PRIORITY-MARK;
}

mode PREPROCESSOR : OPERATORS, 
                    VAR_LEXEMES, 
                    EOF_AND_FAILURE
<skip:       [ \r\t]>
<skip_range: "/*" "*/">
{
    defined          => TKN_PP_DEFINED(LexemeNull);

    "#"              => TKN_HASH(LexemeNull);
    "##"             => TKN_DOUBLE_HASH(LexemeNull);

    "//"[^\n]*"\n"  => GOTO(PROGRAM, TKN_PP_FINISH);
	"\n"            => GOTO(PROGRAM, TKN_PP_FINISH); 
	"\\\n"          {}
	"\\\r\n"        {}
	{P_IDENTIFIER}  PRIORITY-MARK;
}
