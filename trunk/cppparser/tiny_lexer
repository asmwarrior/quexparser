/* -*- C++ -*-   vim: set syntax=cpp:
 * CONTENT: 
 *
 * (1) Includes for required standard headers.
 * (2) Definitions of options and settings for the particular application.
 * (3) #include <quex/code_base/definitions> for default settings.
 * (4) Lexical Analyzer class tiny_lexer and its memento class.
 * (5) Constructor and init core of tiny_lexer.
 * (6) Memento pack and unpack functions.
 *
 * File content generated by Quex 0.50.1.
 *
 * (C) 2005-2010 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                                      */
#ifndef __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____TINY_LEXER
#define __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____TINY_LEXER

#ifdef      __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
    /* In case that multiple lexical analyzers are used the same header
     * files are compiled with a different setting of the macros. The
     * undef of the include guards happens in the following file.              */
#   include <quex/code_base/include-guard-undef>
#   include <quex/code_base/analyzer/member/token-sending-undef.i>
#   undef   __QUEX_INCLUDE_GUARD__ANALYZER__CONFIGURATION____QUEX____TINY_LEXER
#else
#   define  __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
#endif

#include "tiny_lexer-configuration"

#include <quex/code_base/definitions>

QUEX_NAMESPACE_MAIN_OPEN
    typedef __QUEX_TYPE_ANALYZER_RETURN_VALUE  (*QUEX_NAME(AnalyzerFunctionP))(QUEX_TYPE_ANALYZER*);
QUEX_NAMESPACE_MAIN_CLOSE

/* Token Class Declaration must preceed the user's header, so that the user
 * can refer to it at ease.                                                    */
QUEX_NAMESPACE_TOKEN_OPEN
    class  Token;
QUEX_NAMESPACE_TOKEN_CLOSE

QUEX_NAMESPACE_MAIN_OPEN
    class tiny_lexer;
QUEX_NAMESPACE_MAIN_CLOSE

/* START: User defined header content _________________________________________
 *        Must come before token class definition, since the token class 
 *        might rely on contents of the header.                                */


/* END: _______________________________________________________________________*/
#include <quex/code_base/analyzer/headers>

#include "tiny_lexer-token_ids"
#include "tiny_lexer-token"

/* START: User's derived class declaration (if there is one) __________________*/

/* END: _______________________________________________________________________*/


QUEX_NAMESPACE_MAIN_OPEN 

enum {
    QUEX_NAME(ModeID_PROGRAM) = 0,
    QUEX_NAME(ModeID_PREPROCESSOR) = 1
};

        extern QUEX_NAME(Mode)  QUEX_NAME(PROGRAM);
        extern QUEX_NAME(Mode)  QUEX_NAME(PREPROCESSOR);


extern     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(PROGRAM_analyzer_function)(QUEX_TYPE_ANALYZER*);
extern     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(PREPROCESSOR_analyzer_function)(QUEX_TYPE_ANALYZER*);
#ifdef __QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern     bool QUEX_NAME(PROGRAM_has_base)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(PROGRAM_has_entry_from)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(PROGRAM_has_exit_to)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(PREPROCESSOR_has_base)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(PREPROCESSOR_has_entry_from)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(PREPROCESSOR_has_exit_to)(const QUEX_NAME(Mode)*);
#endif



typedef struct QUEX_NAME(Memento_tag) {
#   include <quex/code_base/analyzer/EngineMemento_body>

    QUEX_NAME(Memento_tag)()  {}  /* Con- and Destruction necessary to trigger */
    ~QUEX_NAME(Memento_tag)() {}  /* con- and destruction of user members.     */

/* START: User's memento extentions ___________________________________________*/

/* END: _______________________________________________________________________*/
} QUEX_NAME(Memento);

QUEX_NAMESPACE_MAIN_CLOSE 

#include <quex/code_base/temporary_macros_on>

QUEX_NAMESPACE_MAIN_OPEN 

class tiny_lexer {
public:
#   include <quex/code_base/analyzer/Engine_body>

    /* DISABLED */ tiny_lexer(const tiny_lexer&);
public:
    tiny_lexer(QUEX_TYPE_CHARACTER* BufferMemoryBegin, size_t  BufferMemorySize,
               QUEX_TYPE_CHARACTER* BufferEndOfFileP      = 0x0,
               const char*          CharacterEncodingName = 0x0,
               bool                 ByteOrderReversionF   = false);
    tiny_lexer(const std::string&   Filename,       
               const char*          CharacterEncodingName = 0x0,
               bool                 ByteOrderReversionF   = false);
    tiny_lexer(std::istream*        p_input_stream, 
               const char*          CharacterEncodingName = 0x0,
               bool                 ByteOrderReversionF   = false);
#   if defined(__QUEX_OPTION_WCHAR_T)
    tiny_lexer(std::wistream*       p_input_stream,
               const char*          CharacterEncodingName = 0x0,
               bool                 ByteOrderReversionF   = false);
#   endif
    tiny_lexer(std::FILE*           input_fh,       
               const char*          CharacterEncodingName = 0x0,
               bool                 ByteOrderReversionF   = false);
#   if defined(__QUEX_OPTION_UNIT_TEST)
    template <class UnderlyingStreamT>
        tiny_lexer(quex::StrangeStream<UnderlyingStreamT>*  p_input_stream, 
                   const char*                              CharacterEncodingName = 0x0,
                   bool                                     ByteOrderReversionF   = false);
#   endif

    virtual ~tiny_lexer();

    /* Direct Access to Memory */
    void*                 buffer_fill_region_append(void* ContentBegin, 
                                                    void* ContentEnd);
    void*                 buffer_fill_region_append_conversion(void* ContentBegin, 
                                                               void* ContentEnd);
    void*                 buffer_fill_region_append_conversion_direct(void* ContentBegin, 
                                                                      void* ContentEnd);
    void                  buffer_fill_region_prepare();
    QUEX_TYPE_CHARACTER*  buffer_fill_region_begin();
    QUEX_TYPE_CHARACTER*  buffer_fill_region_end();
    size_t                buffer_fill_region_size();
    void                  buffer_fill_region_finish(const size_t LoadedN);
    void                  buffer_conversion_fill_region_prepare(); 
    uint8_t*              buffer_conversion_fill_region_begin();
    uint8_t*              buffer_conversion_fill_region_end();
    size_t                buffer_conversion_fill_region_size();
    void                  buffer_conversion_fill_region_finish(const size_t  ByteN);
    QUEX_TYPE_CHARACTER*  buffer_lexeme_start_pointer_get();
    void                  buffer_input_pointer_set(QUEX_TYPE_CHARACTER*);

    // -- activate/deactivate byte order reversion (big-/little-endian)
    bool                  byte_order_reversion();
    void                  byte_order_reversion_set(bool Value);

#   if   defined(QUEX_OPTION_TOKEN_POLICY_QUEUE)
    QUEX_TYPE_TOKEN*      receive();
#   elif defined(QUEX_OPTION_TOKEN_POLICY_SINGLE)
    QUEX_TYPE_TOKEN_ID    receive();
#   endif
    // NOTE: A pointer to an object of the token queue/object is used in order to make
    //       memory management more flexible. The token queue/token object is heavily
    //       used and it should be possible to put it somewhere in memory with other
    //       heavily used data so that the cache can take advantage of data locality.
    QUEX_TYPE_TOKEN*   token_p();

#   if defined(QUEX_OPTION_TOKEN_POLICY_SINGLE) 
#      if defined(QUEX_OPTION_USER_MANAGED_TOKEN_MEMORY)
       QUEX_TYPE_TOKEN*  token_p_switch(QUEX_TYPE_TOKEN*);
#      endif
#   else
       bool     token_queue_is_empty();
       void     token_queue_remainder_get(QUEX_TYPE_TOKEN** begin, QUEX_TYPE_TOKEN** end);
#      if defined(QUEX_OPTION_USER_MANAGED_TOKEN_MEMORY)
       void     token_queue_memory_switch(QUEX_TYPE_TOKEN** begin, size_t* n);
#      endif
#   endif

    //
    // (*) Mode handling
    //
    //     -- modes: read access
    QUEX_NAME(Mode)&      mode();
    int                   mode_id() const;
    const char*           mode_name() const;
    //
    //     -- modes: changing lexical analysis mode
    void        set_mode_brutally(const int       LexerMode);
    void        set_mode_brutally(const QUEX_NAME(Mode)& Mode);
    //
    void        operator<<(const int MODE_ID);               
    void        operator<<(/* NOT const*/ QUEX_NAME(Mode)& Mode);  
    //
    void        pop_mode();
    void        pop_drop_mode();
    void        push_mode(QUEX_NAME(Mode)& new_mode);
    //
    void        enter_mode(/* NOT const*/ QUEX_NAME(Mode)& TargetMode);
    //
    //     -- map: mode id to mode and vice versa
    QUEX_NAME(Mode)&   map_mode_id_to_mode(const int              ModeID);       
    int                map_mode_to_mode_id(const QUEX_NAME(Mode)& Mode) const;

    // (*) Token sending happens only via 'self_send*(...)' macros
    void        send(const QUEX_TYPE_TOKEN_ID TokenID)
    { QUEX_ERROR_DEPRECATED("Member functions .send()", "macros: self_send*()"); }

#   ifdef  QUEX_OPTION_LINE_NUMBER_COUNTING
    size_t      line_number() const          { return line_number_at_begin(); }
    size_t      line_number_at_begin() const { return counter.base._line_number_at_begin; }
    size_t      line_number_at_end() const   { return counter.base._line_number_at_end; }
#   endif
#   ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
    size_t      column_number() const          { return column_number_at_begin(); }
    size_t      column_number_at_begin() const { return counter.base._column_number_at_begin; }
    size_t      column_number_at_end() const   { return counter.base._column_number_at_end; }
#   endif
#   ifdef       __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT
    size_t      indentation()                    { return counter._indentation; }
    void        disable_next_indentation_event() { counter._indentation_event_enabled_f = false; }
#   endif

    // (*) Version information
    const char* version() const; // created by quex for version/date information

    // (*) Tell/Seek/Move on basis of character index
    void        move_forward(const size_t);
    void        move_backward(const size_t);
    size_t      tell();
    void        seek(const size_t);

public:
    template <class InputHandleT> void reset(InputHandleT*  input_handle, 
                                             const char*    CharacterEncodingName = 0x0);
    void                               reset(const char*    CharacterEncodingName = 0x0) 
    { reset<void>((void*)0x0, CharacterEncodingName); }

#   ifdef QUEX_OPTION_INCLUDE_STACK
public:
    template<class InputHandleT> void  include_push(QUEX_TYPE_CHARACTER*     InputName, 
                                                    const QUEX_NAME(Mode)*   Mode            = 0x0, 
                                                    const char*              IANA_CodingName = 0x0);
    template<class InputHandleT> void  include_push(InputHandleT*            sh, 
                                                    const QUEX_NAME(Mode)*   Mode            = 0x0, 
                                                    const char*              IANA_CodingName = 0x0);
    bool                               include_pop();

protected:
    void                               include_stack_delete();

private:
#   endif

public:
    void  print_this();

private:
    // (*) Common core of all constructors ___________________________________________
    TEMPLATE_IN(InputHandleT) friend void
    QUEX_NAME(constructor_core)(QUEX_TYPE_ANALYZER*       me,
                                InputHandleT*             input_handle, 
                                const char*               CharacterEncodingName,
                                bool                      ByteOrderReversionF,
                                QUEX_TYPE_CHARACTER*      BufferMemory,    
                                size_t                    BufferMemorySize);

    template<class InputHandleT> friend QUEX_NAME(Memento)*
    QUEX_NAME(memento_pack)(QUEX_TYPE_ANALYZER*, QUEX_TYPE_CHARACTER*, 
                            InputHandleT**);
    friend void
    QUEX_NAME(memento_unpack)(QUEX_TYPE_ANALYZER*, QUEX_NAME(Memento)*);

    template<class InputHandleT> friend void
    QUEX_NAME(reset)(QUEX_TYPE_ANALYZER*, InputHandleT*, const char*);

    /* (*) All Modes are Friends ___________________________________________________*/
    friend     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(PROGRAM_analyzer_function)(QUEX_TYPE_ANALYZER*);
    friend     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(PREPROCESSOR_analyzer_function)(QUEX_TYPE_ANALYZER*);
#ifdef __QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
    friend     bool QUEX_NAME(PROGRAM_has_base)(const QUEX_NAME(Mode)*);
    friend     bool QUEX_NAME(PROGRAM_has_entry_from)(const QUEX_NAME(Mode)*);
    friend     bool QUEX_NAME(PROGRAM_has_exit_to)(const QUEX_NAME(Mode)*);
    friend     bool QUEX_NAME(PREPROCESSOR_has_base)(const QUEX_NAME(Mode)*);
    friend     bool QUEX_NAME(PREPROCESSOR_has_entry_from)(const QUEX_NAME(Mode)*);
    friend     bool QUEX_NAME(PREPROCESSOR_has_exit_to)(const QUEX_NAME(Mode)*);
#endif

  

public:
#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)this)
/* START: User's class body extensions _____________________________________________*/

/* END: ____________________________________________________________________________*/
#undef  self

public:
    // At least warn those, who still use the old interface ...
    void                  get_token() 
    { QUEX_ERROR_DEPRECATED("Member functions .get_token()", ".receive(...)"); }
    void                  get_token(QUEX_TYPE_TOKEN*   result_p) { get_token(); }
    void                  get_token(QUEX_TYPE_TOKEN**  result_p) { get_token(); }
};

QUEX_NAMESPACE_MAIN_CLOSE
#include <quex/code_base/temporary_macros_off>

#include <quex/code_base/temporary_macros_on>

QUEX_NAMESPACE_MAIN_OPEN

#ifndef __QUEX_OPTION_PLAIN_C
TEMPLATE_IN(InputHandleT)
#endif
void
QUEX_NAME(constructor_core)(QUEX_TYPE_ANALYZER*    me,
                            InputHandleT*          input_handle, 
                            const char*            CharacterEncodingName,
                            bool                   ByteOrderReversionF,
                            QUEX_TYPE_CHARACTER*   BufferMemory,    
                            size_t                 BufferMemorySize,
                            QUEX_TYPE_CHARACTER*   BufferEndOfFileP)
{
        __quex_assert(QUEX_NAME(ModeID_PROGRAM)      < 2);
        __quex_assert(QUEX_NAME(ModeID_PREPROCESSOR) < 2);

     QUEX_NAME(PROGRAM).id   = QUEX_NAME(ModeID_PROGRAM);
     QUEX_NAME(PROGRAM).name = "PROGRAM";
     QUEX_NAME(PROGRAM).analyzer_function = QUEX_NAME(PROGRAM_analyzer_function);
#    ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT    
     QUEX_NAME(PROGRAM).on_indentation = QUEX_NAME(Mode_on_indentation_null_function);
#    endif
     QUEX_NAME(PROGRAM).on_entry       = QUEX_NAME(Mode_on_entry_exit_null_function);
     QUEX_NAME(PROGRAM).on_exit        = QUEX_NAME(Mode_on_entry_exit_null_function);
#    ifdef __QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
     QUEX_NAME(PROGRAM).has_base       = QUEX_NAME(PROGRAM_has_base);
     QUEX_NAME(PROGRAM).has_entry_from = QUEX_NAME(PROGRAM_has_entry_from);
     QUEX_NAME(PROGRAM).has_exit_to    = QUEX_NAME(PROGRAM_has_exit_to);
#    endif

     QUEX_NAME(PREPROCESSOR).id   = QUEX_NAME(ModeID_PREPROCESSOR);
     QUEX_NAME(PREPROCESSOR).name = "PREPROCESSOR";
     QUEX_NAME(PREPROCESSOR).analyzer_function = QUEX_NAME(PREPROCESSOR_analyzer_function);
#    ifdef __QUEX_OPTION_INDENTATION_TRIGGER_SUPPORT    
     QUEX_NAME(PREPROCESSOR).on_indentation = QUEX_NAME(Mode_on_indentation_null_function);
#    endif
     QUEX_NAME(PREPROCESSOR).on_entry       = QUEX_NAME(Mode_on_entry_exit_null_function);
     QUEX_NAME(PREPROCESSOR).on_exit        = QUEX_NAME(Mode_on_entry_exit_null_function);
#    ifdef __QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
     QUEX_NAME(PREPROCESSOR).has_base       = QUEX_NAME(PREPROCESSOR_has_base);
     QUEX_NAME(PREPROCESSOR).has_entry_from = QUEX_NAME(PREPROCESSOR_has_entry_from);
     QUEX_NAME(PREPROCESSOR).has_exit_to    = QUEX_NAME(PREPROCESSOR_has_exit_to);
#    endif
        me->mode_db[QUEX_NAME(ModeID_PROGRAM)]      = &(QUEX_NAME(PROGRAM));
        me->mode_db[QUEX_NAME(ModeID_PREPROCESSOR)] = &(QUEX_NAME(PREPROCESSOR));


    QUEX_NAME(construct_basic)(me, input_handle,
                               BufferMemory, BufferMemorySize, BufferEndOfFileP,
                               CharacterEncodingName, 
                               QUEX_SETTING_TRANSLATION_BUFFER_SIZE,
                               ByteOrderReversionF);

    me->__current_mode_p = 0x0; /* REQUIRED, for mode transition check */
    QUEX_NAME(set_mode_brutally_by_id)(me, __QUEX_SETTING_INITIAL_LEXER_MODE_ID);

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's constructor extensions _______________________________________*/

/* END: _______________________________________________________________________*/
#undef self
}


#ifdef QUEX_OPTION_INCLUDE_STACK

#ifndef __QUEX_OPTION_PLAIN_C
TEMPLATE_IN(InputHandleT)
#endif
QUEX_NAME(Memento)*
QUEX_NAME(memento_pack)(QUEX_TYPE_ANALYZER*   me, 
                        QUEX_TYPE_CHARACTER*  InputName, 
                        InputHandleT**        input_handle)
{
#   define self  (*me)
    QUEX_NAME(Memento)* memento = QUEX_NAME(MemoryManager_Memento_allocate)();

#   ifndef __QUEX_OPTION_PLAIN_C
    /* Use placement 'new' for explicit call of constructor. 
     * Necessary in C++: Trigger call to constructor for user defined members.   */
    new ((void*)memento) QUEX_NAME(Memento);
#   endif

    memento->_parent_memento                  = self._parent_memento;
    memento->buffer                           = self.buffer;
    memento->__current_mode_p                 = self.__current_mode_p; 
    memento->current_analyzer_function        = self.current_analyzer_function;
#   if    defined(QUEX_OPTION_AUTOMATIC_ANALYSIS_CONTINUATION_ON_MODE_CHANGE) \
       || defined(QUEX_OPTION_ASSERTS)
    memento->DEBUG_analyzer_function_at_entry = self.DEBUG_analyzer_function_at_entry;
#   endif
    memento->counter                          = self.counter;
#   ifdef QUEX_OPTION_STRING_ACCUMULATOR
    memento->accumulator                      = self.accumulator;
#   endif
    memento->__file_handle_allocated_by_constructor = self.__file_handle_allocated_by_constructor;

    /* Deriberately not subject to include handling:
     *    -- Mode stack.
     *    -- Token and token queues.
     *    -- Post categorizer.                                                 */

#   ifdef QUEX_OPTION_TOKEN_POLICY_QUEUE
    /* QuexTokenQueueRemainder_restore(&memento->token_queue_remainder, &self._token_queue); */
#   endif

/* START: User's memento 'pack' _______________________________________________*/

/* END: _______________________________________________________________________*/

    return memento;
#   undef self
}

#ifndef __QUEX_OPTION_PLAIN_C
QUEX_INLINE 
#endif
void
QUEX_NAME(memento_unpack)(QUEX_TYPE_ANALYZER*  me, 
                          QUEX_NAME(Memento)*  memento)
{
#   define self  (*me)
    self._parent_memento                  = memento->_parent_memento;
    self.buffer                           = memento->buffer;
    self.__current_mode_p                 = memento->__current_mode_p; 
    self.current_analyzer_function        = memento->current_analyzer_function;
#   if    defined(QUEX_OPTION_AUTOMATIC_ANALYSIS_CONTINUATION_ON_MODE_CHANGE) \
       || defined(QUEX_OPTION_ASSERTS)
    self.DEBUG_analyzer_function_at_entry = memento->DEBUG_analyzer_function_at_entry;
#   endif
    self.counter                          = memento->counter;
#   ifdef QUEX_OPTION_STRING_ACCUMULATOR
    self.accumulator                      = memento->accumulator;
#   endif
    self.__file_handle_allocated_by_constructor = memento->__file_handle_allocated_by_constructor;

#   ifdef QUEX_OPTION_TOKEN_POLICY_QUEUE
    /* QuexTokenQueueRemainder_restore(&memento->token_queue_remainder, &self._token_queue); */
#   endif

/* START: User's memento 'unpack' _____________________________________________*/

/* END: _______________________________________________________________________*/
    
#   ifndef __QUEX_OPTION_PLAIN_C
    /* Counterpart to placement new: Explicit destructor call.
     * Necessary in C++: Trigger call to destructor for user defined members.  */
    memento->~QUEX_NAME(Memento_tag)();
#   endif

    QUEX_NAME(MemoryManager_Memento_free)(memento);
#   undef self
}
#endif /* QUEX_OPTION_INCLUDE_STACK */

QUEX_NAMESPACE_MAIN_CLOSE

#include <quex/code_base/temporary_macros_off>


#include <quex/code_base/analyzer/headers.i>

#endif /* __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____TINY_LEXER */
